EnableAutoConfiguration,spring-cloud-openfeign-core/META_INF/spring.factory

Feign的基本注入配置FeignAutoConfiguration（属性配置FeignClientProperties、FeignHttpClientProperties）

Targeter上可配置HystrixTargeter或DefaultTargeter；Client上支持Apache Http和OkHttp。

当启用Ribbon时，基本注入配置增加使用FeignRibbonClientAutoConfiguration；Client用LoadBalancerFeignClient进行包装。CachingSpringLoadBalancerFactory缓存了FeignLoadBalancer。



客户端使用时，标注EnableFeignClients，FeignClientsRegistrar执行注入工作，扫描所有标注了FeignClient的接口（配置可以个性化），实际注入容器的是FeignClientFactoryBean。

进入FeignClientFactoryBean，核心方法getTarget。（在FeignContext中，每一个FeignClient用ContextId来区分配置）（Feign的日志系统取决于FeignContext中注入的FeignLoggerFactory实际是什么，支持接入日志系统、error console等）（其它Encoder、Decoder、Contract和日志系统同理）；url不指定时，采用name作为请求地址（默认http；url指定时，会取LoadBalancerFeignClient的delegate，不知道这一步的原因）；最后交由Targeter获取目标类。

{想到一个问题，注入的bean是怎么到子ApplicationContext而不是Spring Boot的ApplicationContext的？FeignClientSpecification里的配置类注入的bean就到子context;在FeignClientsRegistrar#registerClientConfiguration}

先看DefaultTargeter，实际工作交给Feign.Builder(具体哪个builder还没找到类注入点，似乎是由使用者项目自己决定是注入Feign.Builder还是HystrixFeign.Builder或者其它；client的基本配置在FeignClientsConfiguration，new FeignContext时注入)构建的ReflectiveFeign；

当使用HystrixTargeter时，最后工作还是给ReflectiveFeign，但是会设置新的invocationHandlerFactory、contract。

ReflectiveFeign#newInstance生成代理类，MethodHandler是最终方法的包装（实现类有SynchronousMethodHandler和DefaultMethodHandler）。{接口默认方法处理比较特别，须了解相关机制}

采用Hystrix时，采用HystrixCommand对代理的invoke方法进行了包装，具体后续再看。

